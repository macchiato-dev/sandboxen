<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QuickJS Sandboxed DOM</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 800px; margin: 2rem auto; padding: 1rem; }
    quickjs-sandbox { display: block; border: 2px dashed #ccc; padding: 1rem; min-height: 100px; border-radius: 8px; }
    .status { color: #666; font-style: italic; margin-bottom: 1rem; }
    button { margin: 0 0.5rem; padding: 0.25rem 0.75rem; }
  </style>
</head>
<body>
  <div class="status" id="status">Loading QuickJS...</div>
  <quickjs-sandbox></quickjs-sandbox>

  <script type="importmap">
  {
    "imports": {
      "quickjs-emscripten-core": "https://cdn.jsdelivr.net/npm/quickjs-emscripten-core@0.31.0/+esm",
      "@jitl/quickjs-singlefile-browser-release-sync": "https://cdn.jsdelivr.net/npm/@jitl/quickjs-singlefile-browser-release-sync@0.31.0/+esm",
      "@jitl/quickjs-ffi-types": "https://cdn.jsdelivr.net/npm/@jitl/quickjs-ffi-types@0.31.0/+esm",
      "quickjs-emscripten-core/emscripten-module": "https://cdn.jsdelivr.net/npm/quickjs-emscripten-core@0.31.0/dist/emscripten-module.js"
    }
  }
  </script>

  <script type="module">
    import { newQuickJSWASMModuleFromVariant } from 'quickjs-emscripten-core';
    import variant from '@jitl/quickjs-singlefile-browser-release-sync';

    const domModule = `
      let host;
      const ID = Symbol.for('nodeId');
      const wrappers = new Map();
      const makeNode = (id) => {
        if (wrappers.has(id)) return wrappers.get(id);
        const n = {
          [ID]: id,
          set textContent(t) { host.setText(this[ID], t); },
          append(...children) { children.forEach(c => host.append(this[ID], c[ID])); },
          addEventListener(type, fn) { host.addListener(this[ID], type, fn); }
        };
        wrappers.set(id, n);
        return n;
      };
      export function setup(h) {
        host = h;
        globalThis.document = {
          createElement: (tag) => { const id = host.createElement(tag); return id < 0 ? null : makeNode(id); },
          createTextNode: (text) => { const id = host.createTextNode(text); return id < 0 ? null : makeNode(id); }
        };
      }
      export function callRun(runFn, rootId) { runFn(makeNode(rootId)); }
      export function getWrapper(id) { return wrappers.get(id); }
    `;

    const userModule = `
      export function run(root) {
        const h = document.createElement('h1');
        h.textContent = 'QuickJS Sandbox Demo';

        const p1 = document.createElement('p');
        p1.textContent = 'This page is powered by JavaScript running inside a QuickJS WebAssembly sandbox.';

        const p2 = document.createElement('p');
        p2.textContent = 'Only a limited set of DOM operations are allowed â€” element creation, text updates, and click events.';

        const p3 = document.createElement('p');
        p3.textContent = 'Use the counter below to see events round-trip through the VM!';

        const p4 = document.createElement('p');
        const decBtn = document.createElement('button');
        decBtn.textContent = '-';
        const countText = document.createTextNode('0');
        const incBtn = document.createElement('button');
        incBtn.textContent = '+';

        let count = 0;
        const handler = (e) => {
          if (e.target === decBtn) count--;
          else if (e.target === incBtn) count++;
          countText.textContent = String(count);
        };
        decBtn.addEventListener('click', handler);
        incBtn.addEventListener('click', handler);
        p4.append(decBtn, countText, incBtn);

        root.append(h, p1, p2, p3, p4);
      }
    `;

    const QuickJS = await newQuickJSWASMModuleFromVariant(variant);

    class QuickJSSandbox extends HTMLElement {
      #vm; #handles = []; #nodes = new Map(); #usedIds = new Set(); #idPool = []; #appendCounts = new Map();
      #createCount = 0; #gas = 1000; #lastRefill = 0;
      static MAX_CREATES = 12; static MAX_TEXT = 512; static MAX_CHILDREN = 5;
      static SCHEMA = { root: ['h1', 'p'], p: ['button', 'text'] };
      static GAS_OP = 5; static GAS_TOPUP = 300; static GAS_REFILL_MS = 1000;

      #useGas() {
        const now = Date.now();
        if (this.#gas < QuickJSSandbox.GAS_OP && now - this.#lastRefill >= QuickJSSandbox.GAS_REFILL_MS) {
          this.#gas = QuickJSSandbox.GAS_TOPUP;
          this.#lastRefill = now;
        }
        if (this.#gas < QuickJSSandbox.GAS_OP) return false;
        this.#gas -= QuickJSSandbox.GAS_OP;
        return true;
      }

      #allocId() {
        while (!this.#idPool.length) {
          const batch = new Uint32Array(16);
          crypto.getRandomValues(batch);
          for (const id of batch) if (!this.#usedIds.has(id)) this.#idPool.push(id);
        }
        const id = this.#idPool.pop();
        this.#usedIds.add(id);
        return id;
      }

      connectedCallback() {
        this.#vm = QuickJS.newContext();
        const vm = this.#vm;

        const rootId = this.#allocId();
        this.#nodes.set(rootId, { el: this, tag: 'root' });

        const domMod = vm.unwrapResult(vm.evalCode(domModule, 'dom.js', { type: 'module' }));
        const getWrapper = vm.getProp(domMod, 'getWrapper');
        this.#handles.push(getWrapper);

        const hostObj = vm.newObject();

        vm.setProp(hostObj, 'createElement', vm.newFunction('createElement', h => {
          if (!this.#useGas()) return vm.newNumber(-1);
          const tag = vm.getString(h).toLowerCase();
          if (this.#createCount >= QuickJSSandbox.MAX_CREATES || !['h1', 'p', 'button'].includes(tag)) return vm.newNumber(-1);
          const id = this.#allocId();
          this.#nodes.set(id, { el: document.createElement(tag), tag });
          this.#createCount++;
          return vm.newNumber(id);
        }));

        vm.setProp(hostObj, 'createTextNode', vm.newFunction('createTextNode', h => {
          if (!this.#useGas()) return vm.newNumber(-1);
          if (this.#createCount >= QuickJSSandbox.MAX_CREATES) return vm.newNumber(-1);
          const id = this.#allocId();
          this.#nodes.set(id, { el: document.createTextNode(vm.getString(h).slice(0, QuickJSSandbox.MAX_TEXT)), tag: 'text' });
          this.#createCount++;
          return vm.newNumber(id);
        }));

        vm.setProp(hostObj, 'setText', vm.newFunction('setText', (idH, textH) => {
          if (!this.#useGas()) return;
          const node = this.#nodes.get(vm.getNumber(idH) >>> 0);
          if (node && ['text', 'button', 'h1', 'p'].includes(node.tag))
            node.el.textContent = vm.getString(textH).slice(0, QuickJSSandbox.MAX_TEXT);
        }));

        vm.setProp(hostObj, 'append', vm.newFunction('append', (parentH, childH) => {
          if (!this.#useGas()) return;
          const [parentId, childId] = [vm.getNumber(parentH) >>> 0, vm.getNumber(childH) >>> 0];
          const [parent, child] = [this.#nodes.get(parentId), this.#nodes.get(childId)];
          if (!parent || !child || !QuickJSSandbox.SCHEMA[parent.tag]?.includes(child.tag)) return;
          const count = this.#appendCounts.get(parentId) || 0;
          if (count >= QuickJSSandbox.MAX_CHILDREN) return;
          this.#appendCounts.set(parentId, count + 1);
          parent.el.appendChild(child.el);
        }));

        vm.setProp(hostObj, 'addListener', vm.newFunction('addListener', (idH, typeH, fnH) => {
          if (!this.#useGas()) return;
          const id = vm.getNumber(idH) >>> 0;
          const node = this.#nodes.get(id);
          if (!node || node.tag !== 'button' || vm.getString(typeH) !== 'click') return;
          const fnHandle = fnH.dup();
          this.#handles.push(fnHandle);
          node.el.addEventListener('click', () => {
            if (!this.#useGas()) return;
            const idNum = vm.newNumber(id);
            const target = vm.unwrapResult(vm.callFunction(getWrapper, vm.undefined, idNum));
            const evt = vm.newObject();
            vm.setProp(evt, 'target', target);
            vm.unwrapResult(vm.callFunction(fnHandle, vm.undefined, evt));
            idNum.dispose();
            evt.dispose();
          });
        }));

        const setup = vm.getProp(domMod, 'setup');
        vm.unwrapResult(vm.callFunction(setup, vm.undefined, hostObj));
        setup.dispose();

        const userMod = vm.unwrapResult(vm.evalCode(userModule, 'user.js', { type: 'module' }));
        const callRun = vm.getProp(domMod, 'callRun');
        const runFn = vm.getProp(userMod, 'run');
        vm.unwrapResult(vm.callFunction(callRun, vm.undefined, runFn, vm.newNumber(rootId)));

        this.#gas = QuickJSSandbox.GAS_TOPUP;
        this.#lastRefill = Date.now();
        [domMod, userMod, callRun, runFn, hostObj].forEach(h => h.dispose());
        document.getElementById('status').textContent = 'QuickJS executed successfully!';
      }

      disconnectedCallback() {
        this.#handles.forEach(h => h.dispose());
        this.#vm?.dispose();
        this.#nodes.clear();
        this.#usedIds.clear();
        this.#idPool.length = 0;
        this.#appendCounts.clear();
      }
    }

    customElements.define('quickjs-sandbox', QuickJSSandbox);
  </script>
</body>
</html>
